import { Injectable } from '@angular/core';
import { Location } from '@angular/common';
import { tap, map } from 'rxjs/operators';
import { createEffect, Actions, ofType } from '@ngrx/effects';
import { get } from 'lodash';

import * as fromActions from '@app/core/store/feature-actions';
import { NavigationQueueService } from '../services/feature/router.service';
import { setParentScreenId, resetParentScreenId } from '@app/core/store';
import { MessagesService as Messages } from '@app/core/services/messages/message.service'
/**
 * Common shared NGRX actions to handle navigation between screens generated by `UI Studio` tool.
 *
 * Please refer to our official documentation for more informations about the supported screens:
 * https://wiki.vermeg.com/display/PFD/Components+Store#ComponentsStore-Screens
 *
 * This class should not be modified.
 */
@Injectable()
export class FeatureEffects {
  constructor(
    private actions$: Actions,
    private location: Location,
    private message: Messages,
    private navigateSer: NavigationQueueService
  ) {}
  /**
   * The effect that clears the current route and then opens the target screen
   * using auxiliary Angular routes in a Popup dialog or above the caller component
   */
  navigateByCallOrDialogAction$ = createEffect(
    () =>
      this.actions$.pipe(
        ofType(fromActions.CALL, fromActions.DIALOG),
        map((payload) => payload),
        tap((payload: any) => {
          this.navigateSer
            .navigate(
              [
                `./`,
                {
                  outlets: {
                    call: null,
                    dialog: null,
                  },
                },
              ],
              {
                relativeTo: payload.activeRoute,
                queryParamsHandling: 'merge',
              }
            )
            .then(() => {
              setParentScreenId(payload.id);
              this.navigateSer.navigate(
                [
                  `./`,
                  {
                    outlets: {
                      [payload['navigationType']]: [
                        payload['feature'],
                        payload['screen'],
                        ...this.getPathParams(payload),
                      ],
                    },
                  },
                ],
                {
                  queryParams: {
                    fc: crypto.getRandomValues(new Uint32Array(1)),
                    ctx: payload.id,
                    ...this.getQueryParams(payload),
                  },
                  relativeTo: payload.activeRoute,
                  queryParamsHandling: 'merge',
                  state: { ...get(payload, 'state', {}) },
                }
              );
            });
        })
      ),
    { dispatch: false }
  );
  /**
   * The effect that opens the target screen in a new page
   */
  navigateBySwitchOrForardAction$ = createEffect(
    () =>
      this.actions$.pipe(
        ofType(fromActions.SWITCH, fromActions.FORWARD),
        map((payload) => payload),
        tap((payload: any) => {
          resetParentScreenId();
          const url = isNaN(payload.workSpaceId)
            ? payload.path
            : `/${payload.workSpaceId}/${payload.path}`;
          this.navigateSer.navigate([url, ...this.getPathParams(payload)], {
            queryParams: {
              fc: crypto.getRandomValues(new Uint32Array(1)),
              ...this.getQueryParams(payload),
            },
            state: { ...get(payload, 'state', {}) },
            replaceUrl: payload['type'] === fromActions.FORWARD ? true : false,
          });
        })
      ),
    { dispatch: false }
  );
  /**
   * The effect that displays the previous caller page
   */
  navigateBackAction$ = createEffect(
    () =>
      this.actions$.pipe(
        ofType(fromActions.BACK),
        map((payload) => payload),
        tap((payload) => {
          this.location.back();
        })
      ),
    { dispatch: false }
  );
  /**
   * The effect that displays the previous caller page
   */
  failedAction$ = createEffect(
    () =>
      this.actions$.pipe(
        ofType(fromActions.failedAction),
        map((payload) => payload),
        tap((payload) => {
          this.message.showErrorHttpMessages(payload, 'error')
        })
      ),
    { dispatch: false }
  );
  /**
   * Gets the shared query parameters
   * @param payload
   */
  private getQueryParams(payload: any) {
    return payload['queryParams'] ? { ...payload['queryParams'] } : {};
  }
  /**
   * Gets the path parameter that is mainly the identifier of the data object to access
   * @param payload
   */
  private getPathParams(payload: any) {
    return payload['pathParams']
      ? [...payload['pathParams']].filter((item) => item !== undefined && item !== null)
      : [];
  }
}
