import { Component, OnInit, Input, ViewChild, inject } from '@angular/core'
import {
  Router,
  ActivatedRoute,
  ActivationStart,
  RouterOutlet,
} from '@angular/router'
import { of, Observable, Subscription } from 'rxjs'
import {
  tap,
  switchMap,
  filter,
  takeUntil,
  shareReplay,
  withLatestFrom,
} from 'rxjs/operators'
import { get } from 'lodash'
import { Store, select } from '@ngrx/store'

import { getValue, getParamValue } from '@app/shared/utils/feature-utils'
import * as fn from '@app/shared/utils/expression-functions'
import * as fromStore from '@app/core/store'
import * as fromMessage from '@features/message/view-message/store'
import { ScreenComponent } from '@core/features/screen.component'
import { HttpClient } from '@angular/common/http'
import { FeatureService } from '@services/feature/feature.service'

import { environment } from '@env/environment'
/**
 * The base REST API path
 */
const BASE_PATH = environment.basePath
/**
 * The feature module's name
 */
const FEATURE = 'Message'
/**
 * The component's name
 */
const SCREEN = 'ViewMessage'
/**
 * This is the base Component that visualizes an object data.
 * This component is auto generated by `UI Studio` tool for a screen of type `View`, please refer to our official documentation for more informations:
 * https://wiki.vermeg.com/display/PFD/Components+Store#ComponentsStore-EditComponentStoreViewscreen
 *
 * It is highly recommended to avoid modifying this class, otherwise you can override all the generated methods & variables in
 * the inherited class MessageViewMessageComponent.
 **/
@Component({ template: '' })
export class MessageViewMessageBaseComponent
  extends ScreenComponent
  implements OnInit
{
  /**
   * Injected Services
   **/

  featureService = inject(FeatureService)
  httpClient = inject(HttpClient)

  /**
   * The stored variables in NGRX State like `page`, `pageSize`, `keys`...etc
   */
  vars: any = {}
  /**
   * The selector of the `loading` state property, it displays a mask when receiving a `true` boolean value
   */
  loading$: Observable<boolean>
  /**
   * The Observable selector of the data value property stored in NGRX State
   */
  data$: Observable<any>
  /**
   * The JSON data stored in the state or provided as input
   */
  @Input() data: any
  /**
   * Property that shows or hides the header of the screen's component
   */
  @Input() showHeader = true
  /**
   * Property that shows or hides the footer of the screen's component
   */
  @Input() showFooter = true
  /**
   * Property that deactivates the navigation routing
   */
  @Input() disableNavigation = false
  /**
   * The technical keys of the input fields
   */
  keys = `message,recipient,sender`

  /**
   * Default  Constructor of the component
   */
  constructor(
    router: Router,
    activeRoute: ActivatedRoute,
    store: Store<fromMessage.State>
  ) {
    super(activeRoute, store, router)
  }
  /**
   * Initializes the state and value of the component by dispatching NGRX Actions
   * Selects and listens to the changes of some properties stored in the state
   */
  ngOnInit() {
    super.ngOnInit()
    this.ctx = fromStore.initScreen(
      FEATURE,
      SCREEN,
      this.screenId,
      this.activeRoute,
      this.parentCtx
    )
    this.store.dispatch(
      fromMessage.initStateAction({
        value: this.data,
        ...this.params,
      })
    )
    !this.data &&
      this.store.dispatch(
        fromMessage.initValueAction({ ...this.getActionPayload() })
      )
    this.data$ = this.store.pipe(
      fromStore.selectData(this.ctx),
      tap((value) => (this.data = { ...this.data, ...value }))
    )
    this.loading$ = this.store.select(fromStore.selectLoading, this.ctx)
  }
  /**
   * Get date format from the profile
   * @param {string} temporalType
   * @param {string} datePrecision
   * @return {string} the date format
   */
  getDateFormat(temporalType: string, datePrecision?: string): string {
    return this.featureService.profileService.getDateFormat(
      temporalType,
      datePrecision
    )
  }
  /**
   * This method returns the feature & screen name
   * @return {object}
   */
  getDescriptor() {
    return { feature: FEATURE, screen: SCREEN }
  }

  /**
   * Returns the payload value to be dispatched in the NGRX actions
   * @returns {object}
   */
  getActionPayload() {
    return {
      ...super.getActionPayload(),
      vars: { ...this.vars, keys: this.keys },
      keys: this.keys,
      data: { ...this.data },
      code: this.featureService.getCode(
        this.parentCtx,
        this.activeRoute.snapshot.params
      ),
    }
  }
}
