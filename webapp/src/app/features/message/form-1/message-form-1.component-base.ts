import { OnInit, ViewChild, Component, inject } from '@angular/core'
import {
  Router,
  ActivatedRoute,
  ActivationStart,
  RouterOutlet,
} from '@angular/router'
import { UntypedFormGroup, Validators, UntypedFormArray } from '@angular/forms'
import { Observable, of, merge, Subscription } from 'rxjs'
import {
  tap,
  map,
  switchMap,
  filter,
  takeUntil,
  withLatestFrom,
  debounceTime,
} from 'rxjs/operators'
import { get, omitBy, mergeWith, isNil, set, cloneDeep, isEmpty } from 'lodash'
import { Store, select } from '@ngrx/store'
import {} from 'primeng/api'
import {
  getValue,
  getParamValue,
  mergeObjects,
} from '@app/shared/utils/feature-utils'
import * as fn from '@app/shared/utils/expression-functions'
import * as fromStore from '@app/core/store'
import { ScreenComponent } from '@core/features/screen.component'
import * as fromMessage from '@features/message/form-1/store'

import { HttpClient } from '@angular/common/http'
import { FeatureService } from '@services/feature/feature.service'

import { environment } from '@env/environment'
/**
 * The base REST API path
 */
const BASE_PATH = environment.basePath
/**
 * The feature module's name
 */
const FEATURE = 'Message'
/**
 * The component's name
 */
const SCREEN = 'Form1'
/**
 * This is the base Component that displays and manages a Reactive Form logic.
 * This component is auto generated by `UI Studio` tool for a screen of type `Edit`, please refer to our official documentation for more informations:
 * https://wiki.vermeg.com/display/PFD/Components+Store#ComponentsStore-EditComponentStoreEditscreen
 *
 * It is highly recommended to avoid modifying this class, otherwise you can override all the generated methods & variables in
 * the inherited class MessageForm1Component.
 **/
@Component({ template: '' })
export class MessageForm1BaseComponent
  extends ScreenComponent
  implements OnInit
{
  /**
   * Injected Services
   **/

  featureService = inject(FeatureService)
  httpClient = inject(HttpClient)

  /**
   * The stored variables in NGRX State like `page`, `pageSize`, `keys`...etc
   */
  vars: any = {}
  /**
   * The selector of the `loading` state property, it displays a mask when receiving a `true` boolean value
   */
  loading$: Observable<boolean>
  /**
   * The Observable selector of the data value property stored in NGRX State
   */
  data$: Observable<any>

  /**
   * The technical keys of the input fields
   */
  keys = `message,sender,recipient`

  /**
   * Default Constructor of the component:
   */
  constructor(
    router: Router,
    store: Store<fromMessage.State>,
    activeRoute: ActivatedRoute
  ) {
    super(activeRoute, store, router)
  }
  /**
   * Initializes the state and value of the component by dispatching NGRX Actions
   * Selects and listens to the changes of some properties stored in the state
   */
  ngOnInit() {
    super.ngOnInit()
    this.form = this.createForm()
    this.ctx = fromStore.initScreen(
      FEATURE,
      SCREEN,
      this.screenId,
      this.activeRoute,
      this.parentCtx
    )
    this.store.dispatch(
      fromMessage.initStateAction({
        ...this.params,
      })
    )
    this.store.dispatch(
      fromMessage.initValueAction({ ...this.getActionPayload() })
    )

    this.data$ = this.store.pipe(
      fromStore.selectFormData(this.ctx),
      tap((item) => this.init(item))
    )
    this.loading$ = this.store.select(fromStore.selectLoading, this.ctx)
    this.form.valueChanges
      .pipe(fromStore.distinctUntilBeChanged, takeUntil(this.destroy$))
      .subscribe((value) => (this.data = mergeObjects(this.data, value)))
  }

  /**
   * Initializes the component by the provided data object
   * @param item
   */
  init(item, isNilEnabled = true) {
    this.data = {
      ...cloneDeep(this.data),
      ...(isNilEnabled ? omitBy(cloneDeep(item), isNil) : cloneDeep(item)),
    }
    this.featureService.patchValue(this.data, this.form)
  }
  /**
   * Store the screen's value in the state
   * @param value
   */
  updateDataInState(value, displayScreen = true) {
    super.updateDataInState(fromMessage.updateDataAction, value, displayScreen)
  }
  /**
   * Get date format from the profile
   * @param {string} temporalType
   * @param {string} datePrecision
   * @return {string} the date format
   */
  getDateFormat(temporalType: string, datePrecision?: string): string {
    return this.featureService.profileService.getDateFormat(
      temporalType,
      datePrecision
    )
  }
  /**
   * This method returns the feature & screen name
   * @return {object}
   */
  getDescriptor() {
    return { feature: FEATURE, screen: SCREEN }
  }

  /**
   * Returns the payload value to be dispatched in the NGRX actions
   * @returns {object}
   */
  getActionPayload() {
    return {
      ...super.getActionPayload(),
      vars: { ...this.vars, keys: this.keys },
      keys: this.keys,
      data: { ...this.data },
      code: this.featureService.getCode(
        this.parentCtx,
        this.activeRoute.snapshot.params
      ),
    }
  }

  /**
   *  Builds the Reactive Form from the configured input fields
   *  @returns {FormGroup}
   */
  createForm(): UntypedFormGroup {
    return this.featureService.formBuilder.group({
      message: [null, [Validators.required]],
      sender: [null, [Validators.required]],
      recipient: [null, [Validators.required]],
    })
  }

  showSend058028(): boolean {
    const id: any = get(this.data, `_id`)
    return id
  }
  showSend(): boolean {
    const id: any = get(this.data, `_id`)
    return !id
  }

  /**
   * Executes the cancel action
   * @return {void}
   */
  doCancel(): void {
    this.store.dispatch(
      fromMessage.cancelAction({ ...this.getActionPayload() })
    )
  }

  /**
   * Executes the send058028 action
   * @return {void}
   */
  doSend058028(): void {
    if (this.form.valid) {
      this.store.dispatch(
        fromMessage.send058028Action({ ...this.getActionPayload() })
      )
    } else {
      this.featureService.validateForm(this.form)
    }
  }

  /**
   * Executes the send action
   * @return {void}
   */
  doSend(): void {
    if (this.form.valid) {
      this.store.dispatch(
        fromMessage.sendAction({ ...this.getActionPayload() })
      )
    } else {
      this.featureService.validateForm(this.form)
    }
  }
}
